@using Tirax.Application.WireMocker.Services

@inherits ReactiveComponentBase<XPortViewModel>

@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject IMockServer MockServer

<MudStack>
    <MudText Typo="Typo.h4">Load</MudText>
    <MudButton StartIcon="@Icons.Material.Filled.Upload" Variant="Variant.Filled" Color="Color.Primary">Load</MudButton>

    <MudText Typo="Typo.h4">Save</MudText>
    <MudButton StartIcon="@Icons.Material.Filled.Download" Variant="Variant.Filled" Color="Color.Primary" OnClick="@Save">Save</MudButton>

    <MudText Typo="Typo.h4">Mappings</MudText>
    <MudText Typo="Typo.body1">Mapping count = @MockServer.Mappings.Length</MudText>

    <MudText Typo="Typo.h5">Load</MudText>
    <MudStack>
        <MudTextField T="string" MaxLength="15000"
                      Label="JSON" Variant="Variant.Outlined" Lines="15" @bind-Value="ViewModel!.Mappings" />
        <MudButton Disabled="!canLoad" Variant="Variant.Filled" Color="Color.Primary" OnClick="@LoadMappings">Load</MudButton>
    </MudStack>
</MudStack>

@code {
    bool canLoad;

    public XPort() {
        this.WhenActivated(disposables => {
            this.WhenAnyValue(x => x.ViewModel!.HasMappings)
                .CombineLatest(ViewModel!.LoadMappings.IsExecuting, (hasMappings, isExecuting) => !isExecuting && hasMappings)
                .Subscribe(loadable => canLoad = loadable)
                .DisposeWith(disposables);

            ViewModel!.Notifications.Subscribe(notification => Snackbar.Add(notification.Message, notification.Severity));
        });
    }

    async Task Save() {
        var content = await ViewModel!.SaveData.Execute();
        using var streamRef = new DotNetStreamReference(content);
        await JS.InvokeVoidAsync("downloadFileFromStream", "wire-mocker.data", streamRef);
    }

    async Task LoadMappings() {
        await ViewModel!.LoadMappings.Execute();
    }
}